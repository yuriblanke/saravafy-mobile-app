export default function PreferencesScreen() {
  
  const router = useRouter();
  const { user, signOut } = useAuth();
  const { showToast } = useToast();
  const queryClient = useQueryClient();
  
  const insets = useGlobalSafeAreaInsets();
  const {
    themeMode,
    setThemeMode,
    effectiveTheme,
    curimbaEnabled,
    setCurimbaEnabled,
    curimbaOnboardingDismissed,
    setCurimbaOnboardingDismissed,
    startPagePreference,
    fetchTerreirosQueAdministro,
  } = usePreferences();

  const variant = effectiveTheme;
  

  const textPrimary =
    variant === "light" ? colors.textPrimaryOnLight : colors.textPrimaryOnDark;
  const textSecondary =
    variant === "light"
      ? colors.textSecondaryOnLight
      : colors.textSecondaryOnDark;
  const textMuted =
    variant === "light" ? colors.textMutedOnLight : colors.textMutedOnDark;

  const inputBg =
    variant === "light" ? colors.inputBgLight : colors.inputBgDark;
  const inputBorder =
    variant === "light" ? colors.inputBorderLight : colors.inputBorderDark;

  const dividerColor =
    variant === "light"
      ? colors.surfaceCardBorderLight
      : colors.surfaceCardBorder;

  const [isEditProfileOpen, setIsEditProfileOpen] = useState(false);
  const [isCurimbaExplainerOpen, setIsCurimbaExplainerOpen] = useState(false);
  const [isCuratorAdminOpen, setIsCuratorAdminOpen] = useState(false);

  const [curatorInviteEmail, setCuratorInviteEmail] = useState("");
  const [curatorInviteInlineError, setCuratorInviteInlineError] = useState<
    string | null
  >(null);
  const [isCreatingCuratorInvite, setIsCreatingCuratorInvite] = useState(false);

  useEffect(() => {
    if (isOpen) return;
    setIsEditProfileOpen(false);
    setIsCurimbaExplainerOpen(false);
    setIsCuratorAdminOpen(false);
    setCuratorInviteEmail("");
    setCuratorInviteInlineError(null);
    setIsCreatingCuratorInvite(false);
  }, [isOpen]);

  const userPhotoUrl =
    (typeof user?.user_metadata?.avatar_url === "string" &&
      user.user_metadata.avatar_url) ||
    (typeof user?.user_metadata?.picture === "string" &&
      user.user_metadata.picture) ||
    undefined;

  const initials = getInitials(
    (typeof user?.user_metadata?.name === "string" &&
      user.user_metadata.name) ||
      user?.email ||
      undefined
  );

  const userDisplayName = getDisplayName(
    (typeof user?.user_metadata?.name === "string" &&
      user.user_metadata.name) ||
      user?.email ||
      undefined
  );

  const userId = user?.id ?? null;
  const userEmail = typeof user?.email === "string" ? user.email : null;
  const normalizedUserEmail = userEmail ? userEmail.trim().toLowerCase() : null;

  // Keep Preferences terreiros list in sync for this user.
  usePreferencesTerreirosRealtime(userId);

  const {
    isCurator,
    isLoading: isCuratorLoading,
    refetch: refetchIsCurator,
  } = useIsCurator();

  const {
    curatorModeEnabled,
    isLoading: curatorModeLoading,
    isSaving: curatorModeSaving,
    setCuratorModeEnabled,
  } = useCuratorMode();

  const { isDevMaster } = useIsDevMaster();

  const shouldShowCurator = !isCuratorLoading && isCurator;

  useEffect(() => {
    if (!isOpen) return;
    void refetchIsCurator();
  }, [isOpen, refetchIsCurator]);

  const curatorModeInfo = useMemo(() => {
    return {
      accessibilityLabel: "Ver detalhes do Modo Curator",
      title: "Modo Curator",
      body: "Ativa os botÃµes de ediÃ§Ã£o do papel de pessoa guardiÃ£ do acervo ao longo de toda a plataforma.",
      sections: [],
    };
  }, []);

  const myTerreirosQuery = usePreferencesTerreirosQuery(userId);
  const myTerreiros = useMemo<MyTerreiroWithRole[]>(
    () => myTerreirosQuery.data ?? [],
    [myTerreirosQuery.data]
  );

  const [terreiroMenuTarget, setTerreiroMenuTarget] =
    useState<MyTerreiroWithRole | null>(null);

  const closeTerreiroMenu = () => setTerreiroMenuTarget(null);

  const openTerreiroMenu = (item: MyTerreiroWithRole) => {
    if (item.role !== "admin" && item.role !== "editor") return;
    setTerreiroMenuTarget(item);
  };

  const curatorInviteQuery = useQuery({
    queryKey: normalizedUserEmail
      ? queryKeys.curatorInvites.pendingForInvitee(normalizedUserEmail)
      : (["curatorInvites", "pendingForInvitee", null] as const),
    enabled: !!userId && !!normalizedUserEmail && isOpen && !isCurator,
    staleTime: 0,
    queryFn: async () => {
      if (!normalizedUserEmail) return null;

      const res: any = await supabase
        .from("curator_invites")
        .select("id, created_at")
        .eq("status", "pending")
        .eq("email", normalizedUserEmail)
        .order("created_at", { ascending: true })
        .limit(1);

      if (res.error) {
        if (__DEV__) {
          console.warn("[PreferencesInvites] curator_invites error", res.error);
        }
        return null;
      }

      const row =
        Array.isArray(res.data) && res.data.length
          ? (res.data[0] as any)
          : null;
      if (!row?.id) return null;

      const invite: PendingCuratorInvite = {
        id: String(row.id),
        created_at: String(row.created_at ?? new Date().toISOString()),
      };

      return invite;
    },
  });

  const terreiroInvitesQuery = useQuery({
    queryKey: normalizedUserEmail
      ? queryKeys.terreiroInvites.pendingForInvitee(normalizedUserEmail)
      : (["terreiroInvites", "pendingForInvitee", null] as const),
    enabled: !!userId && !!normalizedUserEmail && isOpen,
    staleTime: 0,
    queryFn: async () => {
      if (!normalizedUserEmail) return [] as PendingTerreiroInvite[];

      const selectWithTitle =
        "id, terreiro_id, role, created_at, terreiro:terreiros(title)";
      const selectWithName =
        "id, terreiro_id, role, created_at, terreiro:terreiros(name)";

      let res: any = await supabase
        .from("terreiro_invites")
        .select(selectWithTitle)
        .eq("status", "pending")
        .eq("email", normalizedUserEmail)
        .order("created_at", { ascending: true });

      if (res.error && isColumnMissingError(res.error.message, "title")) {
        res = await supabase
          .from("terreiro_invites")
          .select(selectWithName)
          .eq("status", "pending")
          .eq("email", normalizedUserEmail)
          .order("created_at", { ascending: true });
      }

      if (res.error) {
        if (__DEV__) {
          console.warn(
            "[PreferencesInvites] terreiro_invites error",
            res.error
          );
        }
        return [] as PendingTerreiroInvite[];
      }

      const rows: any[] = Array.isArray(res.data) ? res.data : [];
      return rows
        .map((row) => {
          const role = String(row?.role ?? "");
          const roleOk =
            role === "admin" ||
            role === "editor" ||
            role === "member" ||
            role === "follower";

          if (!row?.id || !row?.terreiro_id || !roleOk) return null;

          const terreiroTitle =
            typeof row?.terreiro?.title === "string"
              ? row.terreiro.title
              : typeof row?.terreiro?.name === "string"
              ? row.terreiro.name
              : null;

          const invite: PendingTerreiroInvite = {
            id: String(row.id),
            terreiro_id: String(row.terreiro_id),
            role: role as InviteRole,
            created_at: String(row.created_at ?? new Date().toISOString()),
            terreiro_title: terreiroTitle,
          };
          return invite;
        })
        .filter(Boolean) as PendingTerreiroInvite[];
    },
  });

  const [inviteProcessingKey, setInviteProcessingKey] = useState<string | null>(
    null
  );

  const [leaveRoleTarget, setLeaveRoleTarget] = useState<{
    terreiroId: string;
    terreiroTitle: string;
    role: Exclude<MyTerreiroRole, "member">;
  } | null>(null);
  const [leaveRoleConfirmText, setLeaveRoleConfirmText] = useState("");
  const [leaveRoleBusy, setLeaveRoleBusy] = useState(false);

  const [isLogoutConfirmOpen, setIsLogoutConfirmOpen] = useState(false);
  const [logoutBusy, setLogoutBusy] = useState(false);

  const isLeaveRoleModalOpen = !!leaveRoleTarget;
  const canConfirmLeaveRole =
    leaveRoleConfirmText.trim().toLowerCase() === "sair";

  const isCannotRemoveLastAdminError = (error: unknown) => {
    const anyErr = error as any;
    const msg = typeof anyErr?.message === "string" ? anyErr.message : "";
    return msg.includes("cannot_remove_last_admin");
  };

  const countActiveAdmins = async (
    terreiroId: string
  ): Promise<number | null> => {
    try {
      let res: any = await supabase
        .from("terreiro_members")
        .select("user_id", { count: "exact", head: true })
        .eq("terreiro_id", terreiroId)
        .eq("role", "admin")
        .eq("status", "active");

      if (res.error && isColumnMissingError(res.error.message, "status")) {
        res = await supabase
          .from("terreiro_members")
          .select("user_id", { count: "exact", head: true })
          .eq("terreiro_id", terreiroId)
          .eq("role", "admin");
      }

      if (res.error) return null;

      const count = typeof res.count === "number" ? res.count : null;
      return count;
    } catch {
      return null;
    }
  };

  const requestLeaveRole = async (item: MyTerreiroWithRole) => {
    if (!userId) return;
    if (item.role !== "admin" && item.role !== "editor") return;

    if (item.role === "admin") {
      const count = await countActiveAdmins(item.id);
      if (count === 1) {
        showToast(
          "Defina outra pessoa admin em Gerenciar acessos antes de sair."
        );
        return;
      }
    }

    setLeaveRoleConfirmText("");
    setLeaveRoleTarget({
      terreiroId: item.id,
      terreiroTitle: item.title,
      role: item.role,
    });
  };

  const closeLeaveRoleModal = () => {
    if (leaveRoleBusy) return;
    setLeaveRoleTarget(null);
    setLeaveRoleConfirmText("");
  };

  const closeLogoutConfirm = () => {
    if (logoutBusy) return;
    setIsLogoutConfirmOpen(false);
  };

  const confirmLogout = async () => {
    if (logoutBusy) return;
    setLogoutBusy(true);
    try {
      await signOut();
    } finally {
      setLogoutBusy(false);
      setIsLogoutConfirmOpen(false);
      closePreferences();
      router.replace("/login");
    }
  };

  const confirmLeaveRole = async () => {
    if (!userId) return;
    if (!leaveRoleTarget) return;
    if (!canConfirmLeaveRole) return;

    setLeaveRoleBusy(true);
    try {
      const rpc = await supabase.rpc("fn_remove_terreiro_member", {
        p_terreiro_id: leaveRoleTarget.terreiroId,
        p_user_id: userId,
      });

      if (rpc.error) {
        if (isCannotRemoveLastAdminError(rpc.error)) {
          showToast(
            "Defina outra pessoa admin em Gerenciar acessos antes de sair."
          );
          return;
        }

        showToast(getFriendlyActionError(rpc.error.message));
        return;
      }

      // Optimistic: remove from list immediately
      queryClient.setQueryData(
        userId ? queryKeys.me.terreirosWithRole(userId) : [],
        (prev: any) => {
          const arr = Array.isArray(prev) ? prev : [];
          return arr.filter(
            (t: any) => String(t?.id ?? "") !== leaveRoleTarget.terreiroId
          );
        }
      );

      // Invalidate related caches
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreirosWithRole(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.membership(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.permissions(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreiros(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreiroAccessIds(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.editableTerreiros(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.terreiros.withRole(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.collections.accountable(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.collections.editableByUserPrefix(userId),
      });

      showToast(
        leaveRoleTarget.role === "admin"
          ? "VocÃª deixou de ser admin deste terreiro."
          : "VocÃª deixou de ser editor(a) deste terreiro."
      );
      closeLeaveRoleModal();
    } finally {
      setLeaveRoleBusy(false);
    }
  };

  const pendingCuratorInvite = curatorInviteQuery.data ?? null;
  const pendingTerreiroInvites = terreiroInvitesQuery.data ?? [];

  const curatorInvitesAdminQuery = useQuery({
    queryKey: ["curatorInvites", "adminList"],
    enabled: !!userId && isDevMaster && isCuratorAdminOpen,
    staleTime: 0,
    queryFn: async () => {
      const res: any = await supabase
        .from("curator_invites")
        .select("id, email, status, created_at")
        .order("created_at", { ascending: false })
        .limit(50);

      if (res.error) {
        if (__DEV__) {
          console.warn(
            "[CuratorInvitesAdmin] curator_invites error",
            res.error
          );
        }
        throw new Error(
          typeof res.error.message === "string" ? res.error.message : "Erro"
        );
      }

      const rows = Array.isArray(res.data) ? res.data : [];
      return rows
        .map((row: any) => {
          const id = String(row?.id ?? "");
          if (!id) return null;
          return {
            id,
            email: String(row?.email ?? ""),
            status: String(row?.status ?? ""),
            created_at: String(row?.created_at ?? ""),
          };
        })
        .filter(Boolean) as {
        id: string;
        email: string;
        status: string;
        created_at: string;
      }[];
    },
  });

  const curatorInvitesAdmin = curatorInvitesAdminQuery.data ?? [];

  const acceptCuratorInvite = async (inviteId: string) => {
    if (!userId) return;
    setInviteProcessingKey(`curator:${inviteId}`);
    try {
      const payload = { p_invite_id: inviteId };
      const res: any = await supabase.rpc("accept_curator_invite", payload);

      if (res?.error) throw res.error;
      if (res?.data === false)
        throw new Error("accept_curator_invite returned false");

      queryClient.setQueryData(
        normalizedUserEmail
          ? queryKeys.curatorInvites.pendingForInvitee(normalizedUserEmail)
          : (["curatorInvites", "pendingForInvitee", null] as const),
        null
      );

      queryClient.invalidateQueries({
        queryKey: normalizedUserEmail
          ? queryKeys.curatorInvites.pendingForInvitee(normalizedUserEmail)
          : (["curatorInvites", "pendingForInvitee", null] as const),
        exact: true,
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.globalRoles.isCurator(userId),
      });

      void refetchIsCurator();

      showToast(`Agora vocÃª Ã© ${getGlobalRoleBadgeLabel("curator")}.`);
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      if (__DEV__) {
        console.error("[PreferencesInvites] accept curator failed", {
          inviteId,
          message,
          raw: e,
        });
      }
      showToast(
        "NÃ£o foi possÃ­vel concluir agora. Verifique sua conexÃ£o e tente novamente."
      );
    } finally {
      setInviteProcessingKey(null);
    }
  };

  const rejectCuratorInvite = async (inviteId: string) => {
    if (!userId) return;
    setInviteProcessingKey(`curator:${inviteId}`);
    try {
      const payload = { p_invite_id: inviteId };
      const res: any = await supabase.rpc("reject_curator_invite", payload);

      if (res?.error) throw res.error;
      if (res?.data === false)
        throw new Error("reject_curator_invite returned false");

      queryClient.setQueryData(
        normalizedUserEmail
          ? queryKeys.curatorInvites.pendingForInvitee(normalizedUserEmail)
          : (["curatorInvites", "pendingForInvitee", null] as const),
        null
      );
      queryClient.invalidateQueries({
        queryKey: normalizedUserEmail
          ? queryKeys.curatorInvites.pendingForInvitee(normalizedUserEmail)
          : (["curatorInvites", "pendingForInvitee", null] as const),
        exact: true,
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.globalRoles.isCurator(userId),
      });

      void refetchIsCurator();

      showToast("Convite recusado.");
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      if (__DEV__) {
        console.error("[PreferencesInvites] reject curator failed", {
          inviteId,
          message,
          raw: e,
        });
      }
      showToast(
        "NÃ£o foi possÃ­vel concluir agora. Verifique sua conexÃ£o e tente novamente."
      );
    } finally {
      setInviteProcessingKey(null);
    }
  };

  const acceptTerreiroInvite = async (invite: PendingTerreiroInvite) => {
    if (!userId) return;
    setInviteProcessingKey(`terreiro:${invite.id}`);
    try {
      let res: any = await supabase.rpc("accept_terreiro_invite", {
        p_invite_id: invite.id,
      });

      if (res?.error && isRpcFunctionParamMismatch(res.error, "p_invite_id")) {
        res = await supabase.rpc("accept_terreiro_invite", {
          invite_id: invite.id,
        });
      }

      if (res?.error) throw res.error;
      if (res?.data === false)
        throw new Error("accept_terreiro_invite returned false");

      // Optimistic: remove invite from list immediately
      if (normalizedUserEmail) {
        queryClient.setQueryData(
          queryKeys.terreiroInvites.pendingForInvitee(normalizedUserEmail),
          (prev: any) => {
            const arr = Array.isArray(prev) ? prev : [];
            return arr.filter((i: any) => String(i?.id ?? "") !== invite.id);
          }
        );
      }

      // Optimistic: add terreiro to "Meus terreiros" immediately (when applicable)
      if (
        invite.role === "admin" ||
        invite.role === "editor" ||
        invite.role === "member"
      ) {
        queryClient.setQueryData(
          queryKeys.me.terreirosWithRole(userId),
          (prev: any) => {
            const arr = Array.isArray(prev) ? prev : [];
            const already = arr.some(
              (t: any) => String(t?.id ?? "") === invite.terreiro_id
            );
            if (already) return arr;
            return [
              ...arr,
              {
                id: invite.terreiro_id,
                title: invite.terreiro_title || "Terreiro",
                cover_image_url: null,
                role:
                  invite.role === "admin"
                    ? "admin"
                    : invite.role === "editor"
                    ? "editor"
                    : "member",
              },
            ];
          }
        );
      }

      let warmOk = true;
      if (invite.role === "admin" || invite.role === "editor") {
        try {
          await fetchTerreirosQueAdministro(userId);
        } catch {
          warmOk = false;
        }
      }

      if (normalizedUserEmail) {
        queryClient.invalidateQueries({
          queryKey:
            queryKeys.terreiroInvites.pendingForInvitee(normalizedUserEmail),
          exact: true,
        });
      }

      queryClient.invalidateQueries({
        queryKey: queryKeys.me.membership(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreiros(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreirosWithRole(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.terreiroAccessIds(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.editableTerreiros(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.me.permissions(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.terreiros.editableByUser(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.collections.accountable(userId),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.collections.editableByUserPrefix(userId),
      });

      if (warmOk) {
        showToast("Convite aceito.");
      } else {
        showToast(
          "Convite aceito, mas nÃ£o foi possÃ­vel atualizar permissÃµes agora. Tente novamente em instantes."
        );
      }
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      if (__DEV__) {
        console.error("[PreferencesInvites] accept terreiro failed", {
          inviteId: invite.id,
          terreiroId: invite.terreiro_id,
          message,
          raw: e,
        });
      }
      showToast(
        "NÃ£o foi possÃ­vel concluir agora. Verifique sua conexÃ£o e tente novamente."
      );
    } finally {
      setInviteProcessingKey(null);
    }
  };

  const rejectTerreiroInvite = async (invite: PendingTerreiroInvite) => {
    if (!userId) return;
    setInviteProcessingKey(`terreiro:${invite.id}`);
    try {
      let res: any = await supabase.rpc("reject_terreiro_invite", {
        p_invite_id: invite.id,
      });

      if (res?.error && isRpcFunctionParamMismatch(res.error, "p_invite_id")) {
        res = await supabase.rpc("reject_terreiro_invite", {
          invite_id: invite.id,
        });
      }

      if (res?.error) throw res.error;
      if (res?.data === false)
        throw new Error("reject_terreiro_invite returned false");

      // Optimistic: remove invite from list immediately
      if (normalizedUserEmail) {
        queryClient.setQueryData(
          queryKeys.terreiroInvites.pendingForInvitee(normalizedUserEmail),
          (prev: any) => {
            const arr = Array.isArray(prev) ? prev : [];
            return arr.filter((i: any) => String(i?.id ?? "") !== invite.id);
          }
        );
      }

      if (normalizedUserEmail) {
        queryClient.invalidateQueries({
          queryKey:
            queryKeys.terreiroInvites.pendingForInvitee(normalizedUserEmail),
          exact: true,
        });
      }

      if (userId) {
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.membership(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.terreiros(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.terreirosWithRole(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.terreiroAccessIds(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.editableTerreiros(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.me.permissions(userId),
        });
        queryClient.invalidateQueries({
          queryKey: queryKeys.collections.editableByUserPrefix(userId),
        });
      }

      showToast("Convite recusado.");
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      if (__DEV__) {
        console.error("[PreferencesInvites] reject terreiro failed", {
          inviteId: invite.id,
          terreiroId: invite.terreiro_id,
          message,
          raw: e,
        });
      }
      showToast(
        "NÃ£o foi possÃ­vel concluir agora. Verifique sua conexÃ£o e tente novamente."
      );
    } finally {
      setInviteProcessingKey(null);
    }
  };

  const didLogPrefsVisibleRef = React.useRef(false);

  useEffect(() => {
    if (!isOpen) {
      didLogPrefsVisibleRef.current = false;
      return;
    }

    if (didLogPrefsVisibleRef.current) return;
    didLogPrefsVisibleRef.current = true;

    if (__DEV__) {
      console.info("[PrefsDebug] visible", {
        userId,
        dataCount: myTerreiros.length,
        isFetching: myTerreirosQuery.isFetching,
      });
    }
  }, [isOpen, myTerreiros.length, myTerreirosQuery.isFetching, userId]);

  const onSelectTheme = (mode: ThemeMode) => {
    setThemeMode(mode);
  };

  const onToggleCurimba = (next: boolean) => {
    setCurimbaEnabled(next);

    if (next && !curimbaOnboardingDismissed) {
      if (__DEV__) {
        console.info("[Curimba] explainer requested (preferences)");
      }
      setIsCurimbaExplainerOpen(true);
    }
  };

  const closeThen = (navigate: () => void) => {
    // Preferences is rendered inside a global RN <Modal />.
    // Any Expo Router navigation while it is open will appear "behind" it.
    // Close first, then navigate on the next tick.
    closePreferences();
    setTimeout(() => {
      navigate();
    }, 0);
  };

  return (
    <>
      {/* Menu de preferÃªncias */}
      <BottomSheet
        visible={
          uiEnabled &&
          isOpen &&
          !isEditProfileOpen &&
          !isCuratorAdminOpen &&
          !isCurimbaExplainerOpen &&
          !terreiroMenuTarget &&
          !isLeaveRoleModalOpen &&
          !isLogoutConfirmOpen
        }
        variant={variant}
        onClose={() => {
          closePreferences();
        }}
      >
        <View style={[styles.menuWrap, { paddingBottom: insets.bottom }]}>
          <View style={styles.pagesList}>
            <PreferencesPageItem
              variant={variant}
              title={userDisplayName}
              afterTitle={
                <View style={styles.profileTitleRight}>
                  <Pressable
                    accessibilityRole="button"
                    accessibilityLabel={`Editar ${userDisplayName}`}
                    onPress={() => {
                      setIsEditProfileOpen(true);
                    }}
                    hitSlop={12}
                    style={({ pressed }) => [
                      styles.profileEditBtn,
                      pressed ? styles.profileEditBtnPressed : null,
                    ]}
                  >
                    <Ionicons name="pencil" size={18} color={textMuted} />
                  </Pressable>
                </View>
              }
              subtitle={
                shouldShowCurator ? (
                  <View style={styles.profileBadgeRow}>
                    <View style={styles.profileBadgeLeft}>
                      <Badge
                        label={getGlobalRoleBadgeLabel("curator")}
                        variant={variant}
                        appearance="primary"
                        style={{ maxWidth: 220 }}
                      />
                      <AccessRoleInfo
                        variant={variant}
                        info={curatorModeInfo}
                      />
                    </View>

                    <View style={styles.profileBadgeRight}>
                      <Switch
                        value={curatorModeEnabled}
                        onValueChange={(next) => {
                          void setCuratorModeEnabled(next);
                        }}
                        disabled={curatorModeLoading || curatorModeSaving}
                      />
                    </View>
                  </View>
                ) : null
              }
              rightAccessory={null}
              showEditButton={false}
              avatarUrl={userPhotoUrl}
              initials={initials}
              onPress={undefined}
              onPressEdit={undefined}
            />

            {!userId || !isDevMaster ? null : (
              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  setIsCuratorAdminOpen(true);
                }}
                style={({ pressed }) => [
                  styles.prefActionRow,
                  {
                    borderColor: dividerColor,
                    backgroundColor: inputBg,
                  },
                  pressed ? styles.prefActionRowPressed : null,
                ]}
              >
                <View style={styles.prefActionLeft}>
                  <Text
                    style={[styles.prefActionTitle, { color: textPrimary }]}
                  >
                    Administrar guardiÃµes
                  </Text>
                </View>

                <Ionicons
                  name="chevron-forward"
                  size={18}
                  color={textSecondary}
                />
              </Pressable>
            )}

            {!shouldShowCurator ? null : (
              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  closeThen(() => {
                    router.push("/review-submissions" as any);
                  });
                }}
                style={({ pressed }) => [
                  styles.prefActionRow,
                  {
                    borderColor: dividerColor,
                    backgroundColor: inputBg,
                  },
                  pressed ? styles.prefActionRowPressed : null,
                ]}
              >
                <View style={styles.prefActionLeft}>
                  <Text
                    style={[styles.prefActionTitle, { color: textPrimary }]}
                  >
                    Revisar envios
                  </Text>
                </View>

                <Ionicons
                  name="chevron-forward"
                  size={18}
                  color={textSecondary}
                />
              </Pressable>
            )}

            {!userId || !normalizedUserEmail ? null : pendingCuratorInvite ? (
              <View
                style={[
                  styles.inviteCard,
                  { borderColor: dividerColor, backgroundColor: inputBg },
                ]}
              >
                <Text
                  style={[styles.inviteTitle, { color: textPrimary }]}
                  numberOfLines={2}
                >
                  Convite
                </Text>
                <Text
                  style={[styles.inviteBody, { color: textSecondary }]}
                  numberOfLines={6}
                >
                  VocÃª foi convidada(o) para cuidar do acervo do Saravafy.
                </Text>

                <View style={styles.inviteActions}>
                  <Pressable
                    accessibilityRole="button"
                    accessibilityLabel="Aceitar convite"
                    disabled={
                      inviteProcessingKey ===
                      `curator:${pendingCuratorInvite.id}`
                    }
                    onPress={() =>
                      void acceptCuratorInvite(pendingCuratorInvite.id)
                    }
                    style={({ pressed }) => [
                      styles.invitePrimaryBtn,
                      { borderColor: colors.brass600 },
                      pressed ? styles.inviteBtnPressed : null,
                      inviteProcessingKey ===
                      `curator:${pendingCuratorInvite.id}`
                        ? styles.inviteBtnDisabled
                        : null,
                    ]}
                  >
                    <Text style={styles.invitePrimaryBtnText}>
                      Aceitar convite
                    </Text>
                  </Pressable>

                  <Pressable
                    accessibilityRole="button"
                    accessibilityLabel="Recusar convite"
                    disabled={
                      inviteProcessingKey ===
                      `curator:${pendingCuratorInvite.id}`
                    }
                    onPress={() =>
                      void rejectCuratorInvite(pendingCuratorInvite.id)
                    }
                    style={({ pressed }) => [
                      styles.inviteSecondaryBtn,
                      { borderColor: inputBorder },
                      pressed ? styles.inviteBtnPressed : null,
                      inviteProcessingKey ===
                      `curator:${pendingCuratorInvite.id}`
                        ? styles.inviteBtnDisabled
                        : null,
                    ]}
                  >
                    <Text
                      style={[
                        styles.inviteSecondaryBtnText,
                        { color: textPrimary },
                      ]}
                      numberOfLines={1}
                    >
                      Recusar convite
                    </Text>
                  </Pressable>
                </View>
              </View>
            ) : null}

            {!userId ||
            !normalizedUserEmail ? null : pendingTerreiroInvites.length ? (
              <View style={styles.invitesList}>
                {pendingTerreiroInvites.map((invite) => {
                  const terreiroTitle =
                    typeof invite.terreiro_title === "string" &&
                    invite.terreiro_title.trim()
                      ? invite.terreiro_title.trim()
                      : "Terreiro";
                  const processing =
                    inviteProcessingKey === `terreiro:${invite.id}`;

                  return (
                    <View
                      key={invite.id}
                      style={[
                        styles.inviteCard,
                        { borderColor: dividerColor, backgroundColor: inputBg },
                      ]}
                    >
                      <Text
                        style={[styles.inviteTitle, { color: textPrimary }]}
                        numberOfLines={2}
                      >
                        Convite para: {terreiroTitle}
                      </Text>
                      <Text
                        style={[styles.inviteBody, { color: textSecondary }]}
                        numberOfLines={3}
                      >
                        FunÃ§Ã£o: {getInviteRoleLabel(invite.role)}
                      </Text>

                      <View style={styles.inviteActions}>
                        <Pressable
                          accessibilityRole="button"
                          accessibilityLabel="Aceitar convite"
                          disabled={processing}
                          onPress={() => void acceptTerreiroInvite(invite)}
                          style={({ pressed }) => [
                            styles.invitePrimaryBtn,
                            { borderColor: colors.brass600 },
                            pressed ? styles.inviteBtnPressed : null,
                            processing ? styles.inviteBtnDisabled : null,
                          ]}
                        >
                          <Text style={styles.invitePrimaryBtnText}>
                            Aceitar convite
                          </Text>
                        </Pressable>

                        <Pressable
                          accessibilityRole="button"
                          accessibilityLabel="Recusar convite"
                          disabled={processing}
                          onPress={() => void rejectTerreiroInvite(invite)}
                          style={({ pressed }) => [
                            styles.inviteSecondaryBtn,
                            { borderColor: inputBorder },
                            pressed ? styles.inviteBtnPressed : null,
                            processing ? styles.inviteBtnDisabled : null,
                          ]}
                        >
                          <Text
                            style={[
                              styles.inviteSecondaryBtnText,
                              { color: textPrimary },
                            ]}
                            numberOfLines={1}
                          >
                            Recusar convite
                          </Text>
                        </Pressable>
                      </View>
                    </View>
                  );
                })}
              </View>
            ) : null}
          </View>

          <View
            style={[styles.blockDivider, { backgroundColor: dividerColor }]}
          />

          <PreferencesSection title="Meus terreiros" variant={variant}>
            <View style={styles.pagesList}>
              {!userId ? null : myTerreirosQuery.isError ? (
                <Pressable
                  accessibilityRole="button"
                  onPress={() => {
                    void myTerreirosQuery.refetch();
                  }}
                  style={({ pressed }) => [
                    styles.retryRow,
                    { borderColor: dividerColor },
                    pressed ? styles.retryRowPressed : null,
                  ]}
                >
                  <Text style={[styles.retryText, { color: textPrimary }]}>
                    Tentar novamente
                  </Text>
                </Pressable>
              ) : myTerreirosQuery.isFetching && myTerreiros.length === 0 ? (
                <Text style={[styles.helperText, { color: textSecondary }]}>
                  Carregando terreirosâ€¦
                </Text>
              ) : myTerreiros.length === 0 ? (
                <Text style={[styles.helperText, { color: textSecondary }]}>
                  VocÃª ainda nÃ£o participa de nenhum terreiro.
                </Text>
              ) : (
                myTerreiros.map((t) => (
                  <PreferencesPageItem
                    key={t.id}
                    variant={variant}
                    title={t.title}
                    avatarUrl={t.cover_image_url ?? undefined}
                    initials={getInitials(t.title)}
                    subtitle={
                      <View style={{ marginTop: 4 }}>
                        <Badge
                          label={
                            t.role === "admin"
                              ? "Admin"
                              : t.role === "editor"
                              ? "Editor"
                              : "Membro"
                          }
                          variant={variant}
                          appearance={
                            t.role === "admin" ? "primary" : "secondary"
                          }
                          style={{ alignSelf: "flex-start" }}
                        />
                      </View>
                    }
                    showEditButton={false}
                    rightAccessory={
                      t.role === "admin" || t.role === "editor" ? (
                        <Pressable
                          accessibilityRole="button"
                          accessibilityLabel="Mais aÃ§Ãµes"
                          hitSlop={12}
                          onPress={(e) => {
                            // Prevent row press.
                            (e as any)?.stopPropagation?.();
                            void Haptics.selectionAsync().catch(
                              () => undefined
                            );
                            openTerreiroMenu(t);
                          }}
                          style={({ pressed }) => [
                            styles.terreiroMenuBtn,
                            pressed ? styles.terreiroMenuBtnPressed : null,
                          ]}
                        >
                          <Ionicons
                            name="ellipsis-vertical"
                            size={18}
                            color={textMuted}
                          />
                        </Pressable>
                      ) : null
                    }
                    onPress={() => {
                      closePreferences();
                      void Haptics.selectionAsync().catch(() => undefined);
                      setTimeout(() => {
                        router.push({
                          pathname: "/terreiro" as any,
                          params: { terreiroId: t.id, terreiroTitle: t.title },
                        });
                      }, 0);
                    }}
                  />
                ))
              )}
            </View>
          </PreferencesSection>

          <View
            style={[styles.blockDivider, { backgroundColor: dividerColor }]}
          />

          <Pressable
            accessibilityRole="button"
            onPress={() => {
              // Keep preferences open; open the editor modal on top.
              router.push({
                pathname: "/terreiro-editor" as any,
                params: { mode: "create" },
              });
            }}
            style={({ pressed }) => [
              styles.createTerreiroBtn,
              { borderColor: colors.brass600 },
              pressed ? styles.createTerreiroBtnPressed : null,
            ]}
          >
            <Text style={styles.createTerreiroText}>Criar novo terreiro</Text>
          </Pressable>

          <View
            style={[styles.blockDivider, { backgroundColor: dividerColor }]}
          />

          <PreferencesSection title="PÃ¡gina inicial" variant={variant}>
            <View style={styles.startPageRow}>
              <Text style={[styles.startPageValue, { color: textPrimary }]}>
                {startPagePreference?.type === "TERREIRO"
                  ? startPagePreference.terreiroTitle ?? "Terreiro"
                  : "Home (Pontos)"}
              </Text>
            </View>
          </PreferencesSection>

          <View
            style={[styles.blockDivider, { backgroundColor: dividerColor }]}
          />

          <PreferencesSection title="AparÃªncia" variant={variant}>
            <Text style={[styles.sectionDesc, { color: textSecondary }]}>
              Escolha como o app deve se comportar visualmente
            </Text>

            <PreferencesRadioGroup
              variant={variant}
              value={themeMode}
              onChange={onSelectTheme}
              options={
                [
                  {
                    key: "system",
                    label: "Sistema",
                    description: "Seguir o dispositivo",
                  },
                  { key: "light", label: "Claro" },
                  { key: "dark", label: "Escuro" },
                ] as const satisfies readonly PreferencesRadioOption<ThemeMode>[]
              }
            />
          </PreferencesSection>

          <View
            style={[styles.blockDivider, { backgroundColor: dividerColor }]}
          />

          <View style={styles.curimbaLogoutWrap}>
            <PreferencesSwitchItem
              variant={variant}
              title="Modo Curimba"
              description="Durante a gira: apenas letras, sem Ã¡udio, e tela sempre ligada."
              value={curimbaEnabled}
              onValueChange={onToggleCurimba}
            />

            <Pressable
              accessibilityRole="button"
              onPress={() => {
                setIsLogoutConfirmOpen(true);
              }}
              style={({ pressed }) => [
                styles.logoutRow,
                pressed ? styles.logoutPressed : null,
              ]}
            >
              <Text style={styles.logoutText}>Sair</Text>
            </Pressable>
          </View>
        </View>
      </BottomSheet>

      <Modal
        transparent
        animationType="fade"
        visible={uiEnabled && isLogoutConfirmOpen}
        onRequestClose={closeLogoutConfirm}
      >
        <Pressable
          style={styles.leaveRoleBackdrop}
          onPress={closeLogoutConfirm}
        >
          <Pressable
            style={[
              styles.leaveRoleCard,
              {
                backgroundColor:
                  variant === "light" ? colors.paper100 : colors.forest900,
                borderColor: dividerColor,
              },
            ]}
            onPress={(e) => {
              (e as any)?.stopPropagation?.();
            }}
          >
            <View style={styles.logoutHeaderRow}>
              <View
                style={[
                  styles.logoutIconWrap,
                  {
                    borderColor: dividerColor,
                    backgroundColor:
                      variant === "light"
                        ? "rgba(220, 38, 38, 0.10)"
                        : "rgba(248, 113, 113, 0.12)",
                  },
                ]}
              >
                <Ionicons
                  name="log-out-outline"
                  size={18}
                  color={colors.danger}
                />
              </View>

              <View style={styles.logoutHeaderTextCol}>
                <Text style={[styles.leaveRoleTitle, { color: textPrimary }]}>
                  Sair do Saravafy
                </Text>
                <Text
                  style={[styles.logoutBody, { color: textSecondary }]}
                  numberOfLines={4}
                >
                  VocÃª serÃ¡ desconectada(o) desta conta neste dispositivo. VocÃª
                  pode entrar novamente quando quiser.
                </Text>
              </View>
            </View>

            <View style={styles.leaveRoleActionsRow}>
              <Pressable
                accessibilityRole="button"
                onPress={closeLogoutConfirm}
                disabled={logoutBusy}
                style={({ pressed }) => [
                  styles.leaveRoleBtn,
                  styles.leaveRoleBtnSecondary,
                  { borderColor: dividerColor },
                  pressed ? styles.leaveRoleBtnPressed : null,
                  logoutBusy ? styles.leaveRoleBtnDisabled : null,
                ]}
              >
                <Text style={[styles.leaveRoleBtnText, { color: textPrimary }]}>
                  Cancelar
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => void confirmLogout()}
                disabled={logoutBusy}
                style={({ pressed }) => [
                  styles.leaveRoleBtn,
                  styles.leaveRoleBtnDanger,
                  pressed ? styles.leaveRoleBtnPressed : null,
                  logoutBusy ? styles.leaveRoleBtnDisabled : null,
                ]}
              >
                <Text style={styles.leaveRoleBtnTextDanger}>
                  {logoutBusy ? "Saindoâ€¦" : "Sair"}
                </Text>
              </Pressable>
            </View>
          </Pressable>
        </Pressable>
      </Modal>

      <BottomSheet
        visible={uiEnabled && isCuratorAdminOpen}
        variant={variant}
        onClose={() => {
          setIsCuratorAdminOpen(false);
          setCuratorInviteEmail("");
          setCuratorInviteInlineError(null);
        }}
      >
        <View style={[styles.menuWrap, { paddingBottom: insets.bottom }]}>
          <Text
            style={[styles.curatorAdminTitle, { color: textPrimary }]}
            numberOfLines={1}
          >
            Administrar guardiÃµes
          </Text>

          <View style={styles.curatorAdminFormRow}>
            <TextInput
              value={curatorInviteEmail}
              onChangeText={(v) => {
                setCuratorInviteEmail(v);
                setCuratorInviteInlineError(null);
              }}
              placeholder="E-mail"
              placeholderTextColor={textSecondary}
              autoCapitalize="none"
              autoCorrect={false}
              keyboardType="email-address"
              style={[
                styles.curatorAdminInput,
                {
                  color: textPrimary,
                  borderColor: inputBorder,
                  backgroundColor: inputBg,
                },
              ]}
            />

            <Pressable
              accessibilityRole="button"
              disabled={isCreatingCuratorInvite}
              onPress={async () => {
                try {
                  const email = normalizeEmail(curatorInviteEmail);
                  if (!email || !email.includes("@")) {
                    setCuratorInviteInlineError("Informe um e-mail vÃ¡lido.");
                    return;
                  }

                  setIsCreatingCuratorInvite(true);

                  const res: any = await supabase.rpc("create_curator_invite", {
                    p_email: email,
                  });

                  if (res?.error) {
                    throw new Error(
                      typeof res.error.message === "string"
                        ? res.error.message
                        : "Erro ao convidar"
                    );
                  }

                  setCuratorInviteEmail("");
                  setCuratorInviteInlineError(null);

                  void curatorInvitesAdminQuery
                    .refetch()
                    .catch(() => undefined);
                  showToast("Convite enviado.");
                } catch (e) {
                  const message = e instanceof Error ? e.message : String(e);
                  setCuratorInviteInlineError(getFriendlyActionError(message));
                } finally {
                  setIsCreatingCuratorInvite(false);
                }
              }}
              style={({ pressed }) => [
                styles.curatorAdminBtn,
                pressed ? styles.inviteBtnPressed : null,
                isCreatingCuratorInvite ? styles.inviteBtnDisabled : null,
              ]}
            >
              <Text style={styles.curatorAdminBtnText}>Convidar</Text>
            </Pressable>
          </View>

          {curatorInviteInlineError ? (
            <Text
              style={[styles.helperText, { color: colors.brass600 }]}
              numberOfLines={3}
            >
              {curatorInviteInlineError}
            </Text>
          ) : null}

          <View
            style={[styles.curatorInvitesCard, { borderColor: dividerColor }]}
          >
            {curatorInvitesAdminQuery.isFetching ? (
              <View style={styles.curatorInviteRow}>
                <Text style={[styles.helperText, { color: textSecondary }]}>
                  Carregando convitesâ€¦
                </Text>
              </View>
            ) : curatorInvitesAdminQuery.isError ? (
              <View style={styles.curatorInviteRow}>
                <Text style={[styles.helperText, { color: textSecondary }]}>
                  NÃ£o foi possÃ­vel carregar os convites.
                </Text>
              </View>
            ) : curatorInvitesAdmin.length === 0 ? (
              <View style={styles.curatorInviteRow}>
                <Text style={[styles.helperText, { color: textSecondary }]}>
                  Nenhum convite encontrado.
                </Text>
              </View>
            ) : (
              curatorInvitesAdmin.map((invite, idx) => (
                <View
                  key={invite.id}
                  style={[
                    styles.curatorInviteRow,
                    idx === 0
                      ? null
                      : {
                          borderTopWidth: StyleSheet.hairlineWidth,
                          borderTopColor: dividerColor,
                        },
                  ]}
                >
                  <View style={{ flex: 1, minWidth: 0 }}>
                    <Text
                      style={[
                        styles.curatorInviteEmail,
                        { color: textPrimary },
                      ]}
                      numberOfLines={1}
                    >
                      {invite.email}
                    </Text>
                    <Text style={[styles.helperText, { color: textSecondary }]}>
                      {invite.status} Â· {formatDateLabel(invite.created_at)}
                    </Text>
                  </View>

                  <View style={styles.curatorInviteRight}>
                    {invite.status === "pending" ? (
                      <Pressable
                        accessibilityRole="button"
                        onPress={async () => {
                          try {
                            const rpc: any = await supabase.rpc(
                              "cancel_curator_invite",
                              {
                                p_invite_id: invite.id,
                              }
                            );

                            if (rpc?.error) {
                              throw new Error(
                                typeof rpc.error.message === "string"
                                  ? rpc.error.message
                                  : "Erro"
                              );
                            }

                            void curatorInvitesAdminQuery
                              .refetch()
                              .catch(() => undefined);
                          } catch (e) {
                            const message =
                              e instanceof Error ? e.message : String(e);
                            showToast(getFriendlyActionError(message));
                          }
                        }}
                        style={({ pressed }) => [
                          styles.curatorInviteCancel,
                          pressed ? styles.inviteBtnPressed : null,
                        ]}
                      >
                        <Text style={styles.curatorInviteCancelText}>
                          Cancelar
                        </Text>
                      </Pressable>
                    ) : null}
                  </View>
                </View>
              ))
            )}
          </View>

          <Image
            source={require("@/assets/images/filler.png")}
            style={styles.curatorAdminFiller}
            resizeMode="contain"
            accessibilityIgnoresInvertColors
          />
        </View>
      </BottomSheet>

      {/* Modal: editar perfil (placeholder silencioso) */}
      <BottomSheet
        visible={uiEnabled && isEditProfileOpen}
        variant={variant}
        onClose={() => setIsEditProfileOpen(false)}
      >
        <View />
      </BottomSheet>

      <BottomSheet
        visible={
          uiEnabled &&
          isOpen &&
          !!terreiroMenuTarget &&
          !isEditProfileOpen &&
          !isCuratorAdminOpen &&
          !isCurimbaExplainerOpen
        }
        variant={variant}
        onClose={closeTerreiroMenu}
        snapPoints={[280]}
      >
        <View style={styles.terreiroMenuSheet}>
          <Text style={[styles.terreiroMenuTitle, { color: textPrimary }]}>
            AÃ§Ãµes do terreiro
          </Text>

          {terreiroMenuTarget ? (
            <Text
              style={[styles.terreiroMenuHint, { color: textSecondary }]}
              numberOfLines={2}
            >
              {terreiroMenuTarget.title}
            </Text>
          ) : null}

          {terreiroMenuTarget?.role === "admin" ? (
            <>
              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  const t = terreiroMenuTarget;
                  if (!t) return;
                  closeTerreiroMenu();
                  router.push({
                    pathname: "/terreiro-members" as any,
                    params: { terreiroId: t.id },
                  });
                }}
                style={({ pressed }) => [
                  styles.terreiroMenuItem,
                  pressed ? styles.terreiroMenuItemPressed : null,
                ]}
              >
                <Text
                  style={[styles.terreiroMenuItemText, { color: textPrimary }]}
                >
                  Gerenciar membros
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  const t = terreiroMenuTarget;
                  if (!t) return;
                  closeTerreiroMenu();
                  router.push({
                    pathname: "/access-manager" as any,
                    params: { terreiroId: t.id, terreiroTitle: t.title },
                  });
                }}
                style={({ pressed }) => [
                  styles.terreiroMenuItem,
                  pressed ? styles.terreiroMenuItemPressed : null,
                ]}
              >
                <Text
                  style={[styles.terreiroMenuItemText, { color: textPrimary }]}
                >
                  Gerenciar gestÃ£o
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  const t = terreiroMenuTarget;
                  if (!t) return;
                  closeTerreiroMenu();
                  router.push({
                    pathname: "/terreiro-editor" as any,
                    params: { mode: "edit", terreiroId: t.id },
                  });
                }}
                style={({ pressed }) => [
                  styles.terreiroMenuItem,
                  pressed ? styles.terreiroMenuItemPressed : null,
                ]}
              >
                <Text
                  style={[styles.terreiroMenuItemText, { color: textPrimary }]}
                >
                  Renomear e editar detalhes
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  const t = terreiroMenuTarget;
                  if (!t) return;
                  closeTerreiroMenu();
                  void requestLeaveRole(t);
                }}
                style={({ pressed }) => [
                  styles.terreiroMenuItem,
                  pressed ? styles.terreiroMenuItemPressed : null,
                ]}
              >
                <Text
                  style={[
                    styles.terreiroMenuItemText,
                    { color: colors.danger },
                  ]}
                >
                  Sair do papel de admin
                </Text>
              </Pressable>
            </>
          ) : terreiroMenuTarget?.role === "editor" ? (
            <Pressable
              accessibilityRole="button"
              onPress={() => {
                const t = terreiroMenuTarget;
                if (!t) return;
                closeTerreiroMenu();
                void requestLeaveRole(t);
              }}
              style={({ pressed }) => [
                styles.terreiroMenuItem,
                pressed ? styles.terreiroMenuItemPressed : null,
              ]}
            >
              <Text
                style={[styles.terreiroMenuItemText, { color: colors.danger }]}
              >
                Sair do papel de editor(a)
              </Text>
            </Pressable>
          ) : null}
        </View>
      </BottomSheet>

      <Modal
        transparent
        animationType="fade"
        visible={uiEnabled && isOpen && isLeaveRoleModalOpen}
        onRequestClose={closeLeaveRoleModal}
      >
        <Pressable
          style={styles.leaveRoleBackdrop}
          onPress={() => {
            closeLeaveRoleModal();
          }}
        >
          <Pressable
            style={[
              styles.leaveRoleCard,
              {
                backgroundColor:
                  variant === "light" ? colors.paper100 : colors.forest900,
                borderColor: dividerColor,
              },
            ]}
            onPress={(e) => {
              (e as any)?.stopPropagation?.();
            }}
          >
            <Text
              style={[styles.leaveRoleTitle, { color: textPrimary }]}
              numberOfLines={2}
            >
              {leaveRoleTarget?.role === "admin"
                ? "Sair do papel de admin?"
                : "Sair do papel de editor(a)?"}
            </Text>

            <Text
              style={[styles.leaveRoleBody, { color: textSecondary }]}
              numberOfLines={6}
            >
              VocÃª perderÃ¡ acesso de gestÃ£o deste terreiro. Para confirmar,
              digite
              {' "sair"'} abaixo.
            </Text>

            {leaveRoleTarget ? (
              <Text style={[styles.leaveRoleHint, { color: textSecondary }]}>
                {leaveRoleTarget.terreiroTitle}
              </Text>
            ) : null}

            <TextInput
              value={leaveRoleConfirmText}
              onChangeText={setLeaveRoleConfirmText}
              placeholder='Digite "sair"'
              placeholderTextColor={textSecondary}
              autoCapitalize="none"
              autoCorrect={false}
              editable={!leaveRoleBusy}
              style={[
                styles.leaveRoleInput,
                {
                  color: textPrimary,
                  borderColor: inputBorder,
                  backgroundColor: inputBg,
                },
              ]}
            />

            <View style={styles.leaveRoleActionsRow}>
              <Pressable
                accessibilityRole="button"
                onPress={closeLeaveRoleModal}
                disabled={leaveRoleBusy}
                style={({ pressed }) => [
                  styles.leaveRoleBtn,
                  styles.leaveRoleBtnSecondary,
                  { borderColor: dividerColor },
                  pressed ? styles.leaveRoleBtnPressed : null,
                  leaveRoleBusy ? styles.leaveRoleBtnDisabled : null,
                ]}
              >
                <Text style={[styles.leaveRoleBtnText, { color: textPrimary }]}>
                  Cancelar
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => void confirmLeaveRole()}
                disabled={leaveRoleBusy || !canConfirmLeaveRole}
                style={({ pressed }) => [
                  styles.leaveRoleBtn,
                  styles.leaveRoleBtnDanger,
                  pressed ? styles.leaveRoleBtnPressed : null,
                  leaveRoleBusy || !canConfirmLeaveRole
                    ? styles.leaveRoleBtnDisabled
                    : null,
                ]}
              >
                <Text style={styles.leaveRoleBtnTextDanger}>
                  {leaveRoleBusy ? "Saindoâ€¦" : "Sair"}
                </Text>
              </Pressable>
            </View>
          </Pressable>
        </Pressable>
      </Modal>

      <CurimbaExplainerBottomSheet
        visible={uiEnabled && isCurimbaExplainerOpen}
        variant={variant}
        dontShowAgain={curimbaOnboardingDismissed}
        onChangeDontShowAgain={setCurimbaOnboardingDismissed}
        onClose={() => setIsCurimbaExplainerOpen(false)}
      />
    </>
  );
}

const styles = StyleSheet.create({

